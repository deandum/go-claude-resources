# Go service main.go template - adapt for your project
# Replace {{.Module}} and {{.AppName}} with actual values

package main

import (
    "context"
    "fmt"
    "log/slog"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"

    "{{.Module}}/internal/config"
)

func main() {
    if err := run(); err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
}

func run() error {
    ctx, stop := signal.NotifyContext(context.Background(),
        syscall.SIGINT, syscall.SIGTERM)
    defer stop()

    cfg, err := config.Load("{{.AppName}}")
    if err != nil {
        return fmt.Errorf("loading config: %w", err)
    }

    var logLevel slog.Level
    if err := logLevel.UnmarshalText([]byte(cfg.LogLevel)); err != nil {
        return fmt.Errorf("invalid log level %q: %w", cfg.LogLevel, err)
    }

    logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
        Level: logLevel,
    }))
    slog.SetDefault(logger)

    // Initialize dependencies here:
    // db, err := postgres.New(ctx, cfg.DatabaseURL)
    // userRepo := user.NewPostgresRepository(db)
    // userSvc := user.NewService(userRepo)
    //
    // orderRepo := order.NewPostgresRepository(db)
    // orderSvc := order.NewService(orderRepo, userSvc)
    //
    // router := http.NewRouter(userSvc, orderSvc)

    srv := &http.Server{
        Addr:         cfg.Addr,
        // Handler:   router,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }

    errCh := make(chan error, 1)
    go func() {
        logger.Info("server starting", "addr", cfg.Addr)
        errCh <- srv.ListenAndServe()
    }()

    select {
    case err := <-errCh:
        return fmt.Errorf("server error: %w", err)
    case <-ctx.Done():
        logger.Info("shutting down gracefully")
    }

    shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    return srv.Shutdown(shutdownCtx)
}
